{
  "_args": [
    [
      {
        "raw": "bagpipe@github:ivshti/bagpipe",
        "scope": null,
        "escapedName": "bagpipe",
        "name": "bagpipe",
        "rawSpec": "github:ivshti/bagpipe",
        "spec": "github:ivshti/bagpipe",
        "type": "hosted",
        "hosted": {
          "type": "github",
          "ssh": "git@github.com:ivshti/bagpipe.git",
          "sshUrl": "git+ssh://git@github.com/ivshti/bagpipe.git",
          "httpsUrl": "git+https://github.com/ivshti/bagpipe.git",
          "gitUrl": "git://github.com/ivshti/bagpipe.git",
          "shortcut": "github:ivshti/bagpipe",
          "directUrl": "https://raw.githubusercontent.com/ivshti/bagpipe/master/package.json"
        }
      },
      "C:\\Users\\Kisora\\Projects\\Files\\node_modules\\linvodb3"
    ]
  ],
  "_from": "ivshti/bagpipe",
  "_id": "bagpipe@0.3.7",
  "_inCache": true,
  "_location": "/bagpipe",
  "_phantomChildren": {},
  "_requested": {
    "raw": "bagpipe@github:ivshti/bagpipe",
    "scope": null,
    "escapedName": "bagpipe",
    "name": "bagpipe",
    "rawSpec": "github:ivshti/bagpipe",
    "spec": "github:ivshti/bagpipe",
    "type": "hosted",
    "hosted": {
      "type": "github",
      "ssh": "git@github.com:ivshti/bagpipe.git",
      "sshUrl": "git+ssh://git@github.com/ivshti/bagpipe.git",
      "httpsUrl": "git+https://github.com/ivshti/bagpipe.git",
      "gitUrl": "git://github.com/ivshti/bagpipe.git",
      "shortcut": "github:ivshti/bagpipe",
      "directUrl": "https://raw.githubusercontent.com/ivshti/bagpipe/master/package.json"
    }
  },
  "_requiredBy": [
    "/linvodb3"
  ],
  "_resolved": "git://github.com/ivshti/bagpipe.git#328cc576d682539d635af3a8c360696af353e44a",
  "_shasum": "cc0e1c7cbf1a39142e71bf93c4fe66d7a2635e74",
  "_shrinkwrap": null,
  "_spec": "bagpipe@github:ivshti/bagpipe",
  "_where": "C:\\Users\\Kisora\\Projects\\Files\\node_modules\\linvodb3",
  "author": {
    "name": "Jackson Tian"
  },
  "bugs": {
    "url": "https://github.com/JacksonTian/bagpipe/issues"
  },
  "dependencies": {
    "inherits": "github:ivshti/inherits"
  },
  "description": "Concurrency limit",
  "devDependencies": {
    "blanket": "*",
    "mocha": "*",
    "pedding": "*",
    "should": "*",
    "travis-cov": "*"
  },
  "directories": {
    "doc": "doc",
    "test": "test"
  },
  "gitHead": "75269c60fdbb897be14575e70a2b86cf43999500",
  "homepage": "https://github.com/JacksonTian/bagpipe#readme",
  "keywords": [
    "limiter",
    "concurrency limit",
    "parallel limit"
  ],
  "license": "MIT",
  "main": "index.js",
  "name": "bagpipe",
  "optionalDependencies": {},
  "readme": "Bagpipe [中文](https://github.com/JacksonTian/bagpipe/blob/master/README_CN.md)\r\n=======\r\nYou are the bagpiper.\r\n\r\n## Introduction\r\nIt is convenient for us to use asynchronism or concurrent to promote our business speed in Node. While, if the amount of concurrent is too large, our server may not support, such that we need to limit the amount of concurrent. Though, the http module contains [http.Agent](http://nodejs.org/docs/latest/api/http.html#http_class_http_agent) to control the amount of sockets, usually, our asynchronous API has packaged in advance. It is not realistic to change the inner API agent, let’s realize it on our own logical layer.\r\n\r\n## Installation\r\n```\r\nnpm install bagpipe\r\n```\r\n\r\n## API\r\nThe APIs exposed by Bagpipe only include constructor and instance methods `push`.\r\n\r\nUnder original status, we may execute concurrent like this, forming 100 concurrent asynchronous invokes.\r\n\r\n```\r\nfor (var i = 0; i < 100; i++) {\r\n  async(function () {\r\n    // Asynchronous call\r\n  });\r\n}\r\n```\r\nIf need to limit concurrency, what is your solution?\r\n\r\nSolution from Bagpipe as follows:\r\n\r\n```\r\nvar Bagpipe = require('bagpipe');\r\n// Sets the max concurrency as 100\r\nvar bagpipe = new Bagpipe(10);\r\nfor (var i = 0; i < 100; i++) {\r\n  bagpipe.push(async, function () {\r\n    // execute asynchronous callback\r\n  });\r\n}\r\n```\r\n\r\nYes, invoke method only splits method、parameter and callback, then delivery it to bagpipe through `push`.\r\n\r\nHow does it like compared with your anticipated solution?\r\n\r\n### Options\r\n\r\n- `refuse`, when queue is fulled, bagpipe will refuse the new async call and execute the callback with a `TooMuchAsyncCallError` exception. default `false`.\r\n- `timeout`, setting global ansyn call timeout. If async call doesn't complete in time, will execute the callback with `BagpipeTimeoutError` exception. default `null`.\r\n\r\n## Principles\r\nBagpipe delivers invoke into inner queue through `push`. If active invoke amount is less than max concurrent, it will be popped and executed directly, or it will stay in the queue. When an asynchronous invoke ends, a invoke in the head of the queue will be popped and executed, such that assures active asynchronous invoke amount no larger than restricted value.\r\n\r\nWhen the queue length is larger than 1, Bagpipe object will fire its `full` event, which delivers the queue length value. The value helps to assess business performance. For example:\r\n\r\n```\r\nbagpipe.on('full', function (length) {\r\n  console.warn('Button system cannot deal on time, queue jam, current queue length is:’+ length);\r\n});\r\n```\r\n\r\nIf queue length more than limit, you can set the `refuse` option to decide continue in queue or refuse call. The `refuse` default `false`. If set as `true`, the `TooMuchAsyncCallError` exception will pass to callback directly:\r\n\r\n```\r\nvar bagpipe = new BagPipe(10, {\r\n  refuse: true\r\n});\r\n```\r\n\r\nIf complete the async call is unexpected, the queue will not balanced. Set the timeout, let the callback executed with the `BagpipeTimeoutError` exception:\r\n\r\n```\r\nvar bagpipe = new BagPipe(10, {\r\n  timeout: 1000\r\n});\r\n```\r\n\r\n## Module status\r\nThe unit testing status: [![Build Status](https://secure.travis-ci.org/JacksonTian/bagpipe.png)](http://travis-ci.org/JacksonTian/bagpipe). Unit test coverage [100%](http://html5ify.com/bagpipe/coverage.html).\r\n\r\n## Best Practices\r\n- Ensure that the last parameter of the asynchronous invoke is callback.\r\n- Listen to the `full` event, adding your business performance assessment.\r\n- Current asynchronous method has not supported context yet. Ensure that there is no `this` reference in asynchronous method. If there is `this` reference in asynchronous method, please use `bind` pass into correct context.\r\n- Asynchronous invoke should process method to deal with timeout, it should ensure the invoke will return in a certain time no matter whether the business has been finished or not.\r\n\r\n## Real case\r\nWhen you want to traverse file directories, asynchrony can ensure `full` use of IO. You can invoke thousands of file reading easily. But, system file descriptors are limited. If disobedient, read this article again when occurring errors as follows.\r\n\r\n```\r\nError: EMFILE, too many open files\r\n```\r\n\r\nSomeone may consider dealing it with synchronous method. But, when synchronous, CPU and IO cannot be used concurrently, performance is an indefeasible index under certain condition. You can enjoy concurrent easily, as well as limit concurrent with Bagpipe.\r\n\r\n```\r\nvar bagpipe = new Bagpipe(10);\r\n\r\nvar files = ['Here are many files'];\r\nfor (var i = 0; i < files.length; i++) {\r\n  // fs.readFile(files[i], 'utf-8', function (err, data) {\r\n  bagpipe.push(fs.readFile, files[i], 'utf-8', function (err, data) {\r\n    // won’t occur error because of too many file descriptors\r\n    // well done\r\n  });\r\n}\r\n```\r\n\r\n## License\r\nReleased under the license of [MIT](https://github.com/JacksonTian/bagpipe/blob/master/MIT-License), welcome to enjoy open source.\r\n\r\n\r\n[![Bitdeli Badge](https://d2weczhvl823v0.cloudfront.net/JacksonTian/bagpipe/trend.png)](https://bitdeli.com/free \"Bitdeli Badge\")\r\n\r\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git://github.com/JacksonTian/bagpipe.git"
  },
  "scripts": {
    "test": "make test-all"
  },
  "version": "0.3.7"
}
